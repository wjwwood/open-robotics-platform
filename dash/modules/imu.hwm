"""
This is a hardware module to interface with our custom IMU.
"""

# Import some useful libraries
from threading import Timer
from time import sleep
from serial import Serial
from lib.hardware import SerialListener

class IMU(Device):
    """This class provides related functionality concerned with interfacing with our custom IMU"""
    def init(self):
        """Function called after object instantiation"""
        # Try to open the log file
        self.log_file = None
        try:
            self.log_file = open(self.config['log_file'], 'w')
        except KeyError as err:
            pass
        # Get the serial port name
        try:
            self.serial_port = self.config['serial']
        except KeyError as err:
            error('%s is missing a configuration.' % self.name)
            raise err
        # Try to open and configure the serial port
        try:
            self.serial = Serial()
            self.serial.port = self.serial_port
            self.serial.timeout = 0.4
            self.serial.baudrate = 115200
            self.serial.open()
        except Exception as err:
            error('Error opening/configuring the serial port for %s' % self.name)
            raise err
        # Synchronize with the IMU
        self.sync()
        # Setup a Serial Listener
        self.serial_listener = SerialListener(self.serial, self.log)
        self.serial_listener.addHandler(True, self.handleMessages)
        self.serial_listener.listen()
        # Initialize some variables
        self.calibrated = None
    
    def sync(self):
        """Attempts to synchronize with the IMU"""
        # Send the Calibrate command to ensure that the IMU is calibrating
        sleep(0.5) # A short pause to let the uC catch up, not sure if this is necessary or not
        debug("IMU Calibrating")
        self.calibrated = None
        self.serial.write('c')
    
    def handleMessages(self, message):
        """Function for handling messages"""
        # Try to log the message
        self.logMessages(message)
        
        # If we care about the message handle it
        if message[0] == 'R':
            self.calibrated = message
            info('IMU Calibrated: %s' % message)
    
    def logMessages(self, message):
        """Logs the messages to a file"""
        try:
            if self.log_file != None:
                self.log_file.write(message)
        except Exception as err:
            error(err)
    
    def shutdown(self):
        """Called when the server shutsdown"""
        self.serial_listener.join()
        del self.serial_listener
    
    def start(self):
        """Called when Control Code Starts"""
        pass
    
    def stop(self):
        """Called when Control Code Stops"""
        pass
    
    @expose
    def getAngle(self):
        """Polls the IMU for one angle, which will be returned in an event at a later point"""
        pass
    
    @expose
    def pollOn(self):
        """Turns angle polling on if it isn't on already"""
        self.serial.write('p')
    
    @expose
    def pollOff(self):
        """Turns angle polling off if it isn't off already"""
        pass
    
    @expose
    def pollToggle(self):
        """Toggles angle polling, if it is off it will turn on, vica versa"""
        pass
    
    @expose
    def zeroAngle(self):
        """Zeros the IMU"""
        pass
    
    @expose
    def calibrate(self):
        """Calibrates the IMU, blocks until calibration is complete"""
        pass
    
    @expose
    def calibrateDeferred(self):
        """Calibrates the IMU, returns immediately and posts an event when complete"""
        pass
    
    @expose
    def turnToAngle(self, destination_angle):
        """Instructs the IMU to turn to a specific angle, returns when the desired angle is reached"""
        pass
    
    @expose
    def turnToAngleDeferred(self):
        """Instructs the IMU to turn to a specific angle, returns immediately, and an event is generated when the target angle is reached"""
        pass
    